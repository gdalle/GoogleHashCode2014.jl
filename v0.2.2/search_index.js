var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GoogleHashCode2014]","category":"page"},{"location":"api/#GoogleHashCode2014.GoogleHashCode2014","page":"API reference","title":"GoogleHashCode2014.GoogleHashCode2014","text":"GoogleHashCode2014\n\nLightweight package designed to interact with the data of the 2014 Google Hash Code.\n\n\n\n\n\n","category":"module"},{"location":"api/#GoogleHashCode2014.City","page":"API reference","title":"GoogleHashCode2014.City","text":"City\n\nStore a city made of Junctions and Streets, along with additional instance parameters.\n\nA City object can be constructed with the function read_city.\n\nFields\n\ntotal_duration::Int: total time allotted for the car itineraries (in seconds)\nnb_cars::Int: number of cars in the fleet\nstarting_junction::Int: index of the junction at which all the cars are located initially (the index refers to a position in the list of junctions)\njunctions::Vector{Junction}: list of junctions\nstreets::Vector{Street}: list of streets\n\nExample\n\njulia> using GoogleHashCode2014\n\njulia> city = read_city()\nCity with 11348 junctions and 17958 streets.\n8 cars all start from junction 4517 and travel for at most 54000s.\n    \njulia> length(city.junctions)\n11348\n    \njulia> length(city.streets)\n17958\n\njulia> city.starting_junction\n4517\n\njulia> city.junctions[10]  # get the junction object at junction index 10\nJunction at coordinates (48.872250900000004, 2.3124588)\n\njulia> city.streets[10]  # get the street object at street index 10\nBidirectional street between junction indices 6814 and 2728 - duration 13s, distance 187m\n\n\n\n\n\n","category":"type"},{"location":"api/#GoogleHashCode2014.Junction","page":"API reference","title":"GoogleHashCode2014.Junction","text":"Junction\n\nStore a junction from a City.\n\ntip: Tip\nJunctions are usually referred to by their integer index in a city's list of junctions. The junction object itself is mainly useful for geographic visualization.\n\nFields\n\nlatitude::Float64: latitude (in decimal degrees)\nlongitude::Float64: longitude (in decimal degrees)\n\nExample\n\njulia> using GoogleHashCode2014\n\njulia> city = read_city();\n\njulia> junction = city.junctions[10]  # get the junction object at junction index 10\nJunction at coordinates (48.872250900000004, 2.3124588)\n\njulia> junction.latitude\n48.872250900000004\n\n\n\n\n\n","category":"type"},{"location":"api/#GoogleHashCode2014.Solution","page":"API reference","title":"GoogleHashCode2014.Solution","text":"Solution\n\nStore a list of itineraries through a City, one for each car in.\n\nA naive Solution can be computed with the function random_walk.\n\nFields\n\nitineraries::Vector{Vector{Int}}: each itinerary is a vector of junction indices\n\nExample\n\njulia> using GoogleHashCode2014, Random\n\njulia> city = read_city();\n\njulia> rng = Random.MersenneTwister(0);\n\njulia> solution = random_walk(rng, city)\nSolution with 8 itineraries of lengths [3810, 3277, 3779, 3278, 3451, 3697, 4366, 3707]\n\njulia> length(solution.itineraries[2])  # number of junctions visited by car nb 2\n3277\n\njulia> solution.itineraries[2][1:10]  # first 10 junction indices visited by car nb 2\n10-element Vector{Int64}:\n  4517\n  1033\n  3656\n  7681\n   398\n  4680\n 10361\n 10089\n 10361\n 10089\n\n\n\n\n\n","category":"type"},{"location":"api/#GoogleHashCode2014.Street","page":"API reference","title":"GoogleHashCode2014.Street","text":"Street\n\nStore an edge between two junctions in a City.\n\ntip: Tip\nA Street refers to junctions with their integer indices, not with the Junction object itself.\n\nFields\n\nendpointA::Int: index of the first junction\nendpointB::Int: index of the second junction\nbidirectional::Bool: whether B -> A is allowed\nduration::Int: time cost of traversing the street (in seconds)\ndistance::Int: length of the street (in meters)\n\nExample\n\njulia> using GoogleHashCode2014\n\njulia> city = read_city();\n\njulia> street = city.streets[10]\nBidirectional street between junction indices 6814 and 2728 - duration 13s, distance 187m\n\njulia> street.bidirectional\ntrue\n\njulia> (street.endpointA, street.endpointB)\n(6814, 2728)\n\njulia> (street.distance / street.duration) * 3.6  # speed on that street in km/h\n51.784615384615385\n\njulia> street = city.streets[11]\nMonodirectional street from junction index 3779 to index 7853 - duration 12s, distance 88m\n\njulia> street.bidirectional\nfalse\n\n\n\n\n\n","category":"type"},{"location":"api/#GoogleHashCode2014.change_duration-Tuple{City, Integer}","page":"API reference","title":"GoogleHashCode2014.change_duration","text":"change_duration(city::City, total_duration::Integer)\n\nReturn a new City with a different total_duration and every other field equal to the ones in city.\n\nExample\n\njulia> using GoogleHashCode2014\n\njulia> city = read_city()\nCity with 11348 junctions and 17958 streets.\n8 cars all start from junction 4517 and travel for at most 54000s.\n\njulia> change_duration(city, 3600)\nCity with 11348 junctions and 17958 streets.\n8 cars all start from junction 4517 and travel for at most 3600s.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.get_street_end-Tuple{Integer, Street}","page":"API reference","title":"GoogleHashCode2014.get_street_end","text":"get_street_end(i, street)\n\nRetrieve the arrival endpoint of street when it starts at junction i.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.is_feasible-Tuple{Solution, City}","page":"API reference","title":"GoogleHashCode2014.is_feasible","text":"is_feasible(solution::Solution, city::City; verbose::Bool=false)\n\nCheck if solution satisfies the constraints for the instance defined by city.\n\nThe following criteria are considered (taken from the problem statement):\n\nthe number of itineraries has to match the number of cars of city\nthe first junction of each itinerary has to be the starting junction of city\nfor each consecutive pair of junctions on an itinerary, a street connecting these junctions has to exist in city (if the street is one directional, it has to be traversed in the correct direction)\nthe duration of each itinerary has to be lower or equal to the total duration of city\n\nExample\n\njulia> using GoogleHashCode2014, Random\n\njulia> city = read_city();\n\njulia> rng = Random.MersenneTwister(0);\n\njulia> solution = random_walk(rng, city)\nSolution with 8 itineraries of lengths [3810, 3277, 3779, 3278, 3451, 3697, 4366, 3707]\n\njulia> is_feasible(solution, city; verbose=false)\ntrue\n\njulia> partial_solution = Solution(solution.itineraries[1:7])\nSolution with 7 itineraries of lengths [3810, 3277, 3779, 3278, 3451, 3697, 4366]\n\njulia> is_feasible(partial_solution, city; verbose=false)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.is_street-Tuple{Integer, Integer, Street}","page":"API reference","title":"GoogleHashCode2014.is_street","text":"is_street(i::Integer, j::Integer, street::Street)\n\nCheck if the trip from junction index i to junction index j corresponds to a valid direction of street.\n\nThe valid directions for a Street are:\n\nfrom street.endpointA to street.endpointB in every case\nfrom street.endpointB to street.endpointA only if street.bidirectional is true\n\nExample\n\njulia> using GoogleHashCode2014\n\njulia> city = read_city(); \n\njulia> street = city.streets[10]\nBidirectional street between junction indices 6814 and 2728 - duration 13s, distance 187m\n\njulia> is_street(1, 2728, street)\nfalse\n\njulia> is_street(6814, 2728, street)\ntrue\n\njulia> is_street(2728, 6814, street)\ntrue\n\njulia> street = city.streets[11]\nMonodirectional street from junction index 3779 to index 7853 - duration 12s, distance 88m\n\njulia> is_street(3779, 7853, street)\ntrue\n\njulia> is_street(7853, 3779, street)  # because it is not bidirectional\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.is_street_start-Tuple{Integer, Street}","page":"API reference","title":"GoogleHashCode2014.is_street_start","text":"is_street_start(i, street)\n\nCheck if junction i corresponds to a valid starting point of street.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.plot_streets","page":"API reference","title":"GoogleHashCode2014.plot_streets","text":"plot_streets(\n    city::City, solution::Union{Solution,Nothing}=nothing;\n    path::Union{AbstractString,Nothing}=nothing\n)\n\nPlot a City and an optional Solution using the Python library folium, save the result as an HTML file at path\n\nThis method is defined in a package extension and requires PythonCall.jl to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"api/#GoogleHashCode2014.random_walk-Tuple{Random.AbstractRNG, City}","page":"API reference","title":"GoogleHashCode2014.random_walk","text":"random_walk(rng::Random.AbstractRNG, city::City)\nrandom_walk(city:::City)\n\nCompute and return a Solution from city by letting each car follow a random walk from its starting point.\n\ntip: Tip\nYou can pass a random number generator with a specific seed, like Random.MersenneTwister(0), to obtain reproducible results. Otherwise, the global random number generator will be used, and the results will be different for every run.\n\nExample\n\njulia> using GoogleHashCode2014, Random\n\njulia> city = read_city();\n\njulia> rng = Random.MersenneTwister(0);\n\njulia> solution = random_walk(rng, city)\nSolution with 8 itineraries of lengths [3810, 3277, 3779, 3278, 3451, 3697, 4366, 3707]\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.read_city","page":"API reference","title":"GoogleHashCode2014.read_city","text":"read_city()\nread_city(path::AbstractString)\n\nParse and return a City, either from the default challenge data (https://storage.googleapis.com/coding-competitions.appspot.com/HC/2014/paris_54000.txt), or from a similarly formatted text file located at path.\n\n\n\n\n\n","category":"function"},{"location":"api/#GoogleHashCode2014.read_solution-Tuple{Any}","page":"API reference","title":"GoogleHashCode2014.read_solution","text":"read_solution(path)\n\nRead and parse a Solution from a file located at path.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.total_distance-Tuple{Solution, City}","page":"API reference","title":"GoogleHashCode2014.total_distance","text":"total_distance(solution::Solution, city::City)\n\nCompute the total distance traveled by all itineraries in solution based on the street data from city.\n\nwarning: Warning\nStreets visited several times or in both directions are only counted once.\n\nExample\n\njulia> using GoogleHashCode2014, Random\n\njulia> city = read_city();\n\njulia> rng = Random.MersenneTwister(0);\n\njulia> solution = random_walk(rng, city)\nSolution with 8 itineraries of lengths [3810, 3277, 3779, 3278, 3451, 3697, 4366, 3707]\n\njulia> total_distance(solution, city)\n752407\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.write_city-Tuple{City, AbstractString}","page":"API reference","title":"GoogleHashCode2014.write_city","text":"write_city(city::City, path::AbstractString)\n\nWrite city to a file located at path.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.write_solution-Tuple{Solution, Any}","page":"API reference","title":"GoogleHashCode2014.write_solution","text":"write_solution(solution, path)\n\nWrite a Solution to a file located at path.\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"#GoogleHashCode2014.jl","page":"Home","title":"GoogleHashCode2014.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Docs) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lightweight package designed to work on the 2014 Google Hash Code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Challenge description: hashcode2014_final_task.pdf\nChallenge data: paris_54000.txt","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given a description of city streets and a number of Street View cars available for a period of time, your task is to schedule the movement of the cars to maximize the total length of city streets that were traversed at least once.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that this package used to be called HashCode2014.jl.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Getting-started","page":"Tutorial","title":"Getting started","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To install this package, just run","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(\"GoogleHashCode2014\")","category":"page"},{"location":"tutorial/#Instance-and-solutions","page":"Tutorial","title":"Instance and solutions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A problem instance is encoded in an object of type City. You can create one for the setting of the challenge (the streets of Paris) as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using GoogleHashCode2014\n\njulia> city = read_city()\nCity with 11348 junctions and 17958 streets.\n8 cars all start from junction 4517 and travel for at most 54000s.\n\njulia> city.junctions[10]  # get the junction object at junction index 10\nJunction at coordinates (48.872250900000004, 2.3124588)\n\njulia> city.streets[10]  # get the street object at street index 10\nBidirectional street between junction indices 6814 and 2728 - duration 13s, distance 187m","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A problem solution is encoded in an object of type Solution. You can generate a random one like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Random: MersenneTwister\n\njulia> rng = MersenneTwister(0);\n\njulia> solution = random_walk(rng, city)\nSolution with 8 itineraries of lengths [3810, 3277, 3779, 3278, 3451, 3697, 4366, 3707]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then, you can check its feasibility and objective value:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> is_feasible(solution, city; verbose=true)\ntrue\n\njulia> total_distance(solution, city)\n752407","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, you can export it to a text file:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> write_solution(solution, joinpath(tempdir(), \"solution.txt\"))\ntrue","category":"page"},{"location":"tutorial/#Visualization","page":"Tutorial","title":"Visualization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you load the package PythonCall.jl, you will be able to visualize a City and its Solution with a nice HTML map. The code below yields an object that is displayed automatically in a Jupyter or Pluto notebook. If you are working outside of a notebook, just open the resulting file \"city_map.html\" in your favorite browser.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PythonCall\ncity_map = plot_streets(city, solution; path=\"city_map.html\")","category":"page"},{"location":"tutorial/#Performance","page":"Tutorial","title":"Performance","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package was designed for pedagogical purposes. It defines types and functions that may be suboptimal in terms of performance. The goal is to invite students to reimplement their own, while providing them with a reliable starting point.","category":"page"}]
}
