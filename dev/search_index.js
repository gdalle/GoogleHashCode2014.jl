var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [GoogleHashCode2014]","category":"page"},{"location":"api/#GoogleHashCode2014.GoogleHashCode2014","page":"API reference","title":"GoogleHashCode2014.GoogleHashCode2014","text":"GoogleHashCode2014\n\nLightweight package designed to interact with the data of the 2014 Google Hash Code.\n\n\n\n\n\n","category":"module"},{"location":"api/#GoogleHashCode2014.City","page":"API reference","title":"GoogleHashCode2014.City","text":"City\n\nStore a city made of Junctions and Streets, along with additional instance parameters.\n\nFields\n\ntotal_duration::Int: total time allotted for the car itineraries (in seconds)\nnb_cars::Int: number of cars in the fleet\nstarting_junction::Int: junction at which all the cars are located initially\njunctions::Vector{Junction}: list of junctions\nstreets::Vector{Street}: list of streets\n\n\n\n\n\n","category":"type"},{"location":"api/#GoogleHashCode2014.Junction","page":"API reference","title":"GoogleHashCode2014.Junction","text":"Junction\n\nStore a city junction.\n\nFields\n\nlatitude::Float64: latitude (in decimal degrees)\nlongitude::Float64: longitude (in decimal degrees)\n\n\n\n\n\n","category":"type"},{"location":"api/#GoogleHashCode2014.Solution","page":"API reference","title":"GoogleHashCode2014.Solution","text":"Solution\n\nStore a set of itineraries, one for each car.\n\nFields\n\nitineraries::Vector{Vector{Int}}: each itinerary is a vector of junction indices\n\n\n\n\n\n","category":"type"},{"location":"api/#GoogleHashCode2014.Street","page":"API reference","title":"GoogleHashCode2014.Street","text":"Street\n\nStore an edge between two Junctions.\n\nFields\n\nendpointA::Int: index of the first junction\nendpointB::Int: index of the second junction\nbidirectional::Bool: whether B -> A is allowed\nduration::Int: time cost of traversing the street (in seconds)\ndistance::Int: length of the street (in meters)\n\n\n\n\n\n","category":"type"},{"location":"api/#GoogleHashCode2014.change_duration-Tuple{City, Any}","page":"API reference","title":"GoogleHashCode2014.change_duration","text":"change_duration(city, total_duration)\n\nCreate a new City with a different total_duration and everything else equal.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.get_street_end-Tuple{Integer, Street}","page":"API reference","title":"GoogleHashCode2014.get_street_end","text":"get_street_end(i, street)\n\nRetrieve the arrival endpoint of street when it starts at junction i.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.is_feasible-Tuple{Solution, City}","page":"API reference","title":"GoogleHashCode2014.is_feasible","text":"is_feasible(solution, city[; verbose=false])\n\nCheck if solution satisfies the constraints for the instance defined by city. The following criteria are considered (taken from the problem statement):\n\nthe number of itineraries has to match the number of cars of city\nthe first junction of each itinerary has to be the starting junction of city\nfor each consecutive pair of junctions on an itinerary, a street connecting these junctions has to exist in city (if the street is one directional, it has to be traversed in the correct direction)\nthe duration of each itinerary has to be lower or equal to the total duration of city\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.is_street-Tuple{Integer, Integer, Street}","page":"API reference","title":"GoogleHashCode2014.is_street","text":"is_street(i, j, street)\n\nCheck if the trip from junction i to junction j corresponds to a valid direction of street.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.is_street_start-Tuple{Integer, Street}","page":"API reference","title":"GoogleHashCode2014.is_street_start","text":"is_street_start(i, street)\n\nCheck if junction i corresponds to a valid starting point of street.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.plot_streets","page":"API reference","title":"GoogleHashCode2014.plot_streets","text":"plot_streets(city, solution=nothing; path=nothing)\n\nPlot a City and an optional Solution using the Python library folium, save the result as an HTML file at path\n\nThis method is defined in a package extension and requires PythonCall.jl to be loaded.\n\n\n\n\n\n","category":"function"},{"location":"api/#GoogleHashCode2014.random_walk-Tuple{Random.AbstractRNG, City}","page":"API reference","title":"GoogleHashCode2014.random_walk","text":"random_walk(rng, city)\nrandom_walk(city)\n\nCreate a solution from a City by letting each car follow a random walk from its starting point.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.read_city","page":"API reference","title":"GoogleHashCode2014.read_city","text":"read_city(path)\n\nRead and parse a City from a file located at path.\n\nThe default path is an artifact containing the official challenge data from https://storage.googleapis.com/coding-competitions.appspot.com/HC/2014/paris_54000.txt.\n\n\n\n\n\n","category":"function"},{"location":"api/#GoogleHashCode2014.read_solution-Tuple{Any}","page":"API reference","title":"GoogleHashCode2014.read_solution","text":"read_solution(path)\n\nRead and parse a Solution from a file located at path.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.total_distance-Tuple{Solution, City}","page":"API reference","title":"GoogleHashCode2014.total_distance","text":"total_distance(solution, city)\n\nCompute the total distance of all itineraries in solution based on the street data from city. Streets visited several times are only counted once.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.write_city-Tuple{City, Any}","page":"API reference","title":"GoogleHashCode2014.write_city","text":"write_city(city, path)\n\nWrite a City to a file located at path.\n\n\n\n\n\n","category":"method"},{"location":"api/#GoogleHashCode2014.write_solution-Tuple{Solution, Any}","page":"API reference","title":"GoogleHashCode2014.write_solution","text":"write_solution(solution, path)\n\nWrite a Solution to a file located at path.\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"#GoogleHashCode2014.jl","page":"Home","title":"GoogleHashCode2014.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lightweight package designed to interact with the data of the 2014 Google Hash Code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Made for MIT course C25: Julia: Solving Real-World Problems with Computation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Challenge description: hashcode2014finaltask.pdf\nChallenge data: paris_54000.txt","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given a description of city streets and a number of Street View cars available for a period of time, your task is to schedule the movement of the cars to maximize the total length of city streets that were traversed at least once.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that this package used to be called HashCode2014.jl.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Getting-started","page":"Tutorial","title":"Getting started","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package is not registered. You need to install it from the GitHub repo with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(url=\"https://github.com/gdalle/GoogleHashCode2014.jl\")","category":"page"},{"location":"tutorial/#Instance-and-solutions","page":"Tutorial","title":"Instance and solutions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A problem instance is encoded in an object of type City. You can create one for the setting of the challenge (the streets of Paris) as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using GoogleHashCode2014\n\njulia> city = read_city()\nCity with 11348 junctions and 17958 streets, where 8 cars must start from junction 4517 and travel for at most 54000 seconds\n\njulia> city.junctions[1]\nJunction located at coordinates (48.8351503, 2.3077904)\n\njulia> city.streets[1]\nMonodirectional street between junctions 8400 and 8402, with duration 4 seconds and distance 36 meters","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A problem solution is encoded in an object of type Solution. You can generate a random one like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Random: MersenneTwister\n\njulia> rng = MersenneTwister(0);\n\njulia> solution = random_walk(rng, city)\nSolution with 8 itineraries of lengths [3810, 3277, 3779, 3278, 3451, 3697, 4366, 3707]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then, you can check its feasibility and objective value:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> is_feasible(solution, city; verbose=true)\ntrue\n\njulia> total_distance(solution, city)\n752407","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, you can export it to a text file:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> write_solution(solution, joinpath(tempdir(), \"solution.txt\"))\ntrue","category":"page"},{"location":"tutorial/#Visualization","page":"Tutorial","title":"Visualization","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you load the package PythonCall.jl, you will be able to visualize a City and its Solution with a nice HTML map. The code below yields an object that is displayed automatically in a Jupyter or Pluto notebook. If you are working outside of a notebook, just open the resulting file \"city_map.html\" in your favorite browser.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using PythonCall\ncity_map = plot_streets(city, solution; path=\"city_map.html\")","category":"page"},{"location":"tutorial/#Performance","page":"Tutorial","title":"Performance","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package was designed for pedagogical purposes. It defines types and functions that may be suboptimal in terms of performance. The goal is to invite students to reimplement their own, while providing them with a reliable starting point.","category":"page"}]
}
